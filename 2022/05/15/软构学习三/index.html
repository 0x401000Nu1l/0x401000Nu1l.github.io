<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="你越安静,你能听到的就越多" href="https://0x401000nu1l.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="你越安静,你能听到的就越多" href="https://0x401000nu1l.github.io/atom.xml"><link rel="alternate" type="application/json" title="你越安静,你能听到的就越多" href="https://0x401000nu1l.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="软件构造学习"><link rel="canonical" href="https://0x401000nu1l.github.io/2022/05/15/%E8%BD%AF%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B8%89/"><title>软构学习三 | 那我就让时光倒流 = 你越安静,你能听到的就越多</title><meta name="generator" content="Hexo 6.1.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">软构学习三</h1><div class="meta"><span class="item" title="Created: 2022-05-15 18:15:52"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-05-15T18:15:52+08:00">2022-05-15</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>6.2k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>6 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">那我就让时光倒流</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclg5ms2rj20zk0m8u0x.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipevo9j1jj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicli9lfebj20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giciub8ja1j20zk0m81ky.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeun65urj20zk0m81ii.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeybxm1pj20zk0m8niv.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="https://0x401000nu1l.github.io/2022/05/15/%E8%BD%AF%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B8%89/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="那我就让时光倒流"><meta itemprop="description" content=", (σﾟ∀ﾟ)σ..:*☆哎哟不错哦"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="你越安静,你能听到的就越多"></span><div class="body md" itemprop="articleBody"><h1 id="课程内容1-4章复习"><a class="anchor" href="#课程内容1-4章复习">#</a> 课程内容 1-4 章复习</h1><h2 id="一多维度视图和质量目标"><a class="anchor" href="#一多维度视图和质量目标">#</a> 一。多维度视图和质量目标</h2><h3 id="总览"><a class="anchor" href="#总览">#</a> 总览</h3><p><img data-src="image-20220613211913950.png" alt="image-20220613211913950"></p><p><img data-src="image-20220613214646742.png" alt="image-20220613214646742"></p><p><strong>运行时</strong></p><p>・Code-level view：代码快照、内存转储；堆栈轨迹、并发线程<br><strong>逻辑实体</strong>在内存中如何呈现</p><p>・Component-level view：包、库、动态链接、数据库、网络、硬件；事件日志、多进程、分布式程序<br><strong>物理实体</strong>在物理硬件环境中如何呈现</p><p>・Moment view：代码快照、内存转储；包、库、动态链接、数据库、网络、硬件<br>逻辑 / 物理实体在内存 / 硬件环境中<strong>特定时刻</strong>的形态</p><p>・Period view：堆栈轨迹、并发线程；事件日志、多进程、分布式程序<br>逻辑 / 物理实体在内存 / 硬件环境中的形态<strong>随时间的变化</strong></p><p>动态链接：库文件不会在构建阶段被加入可执行软件，仅仅做出标记；程序运行时，根据标记装载库至内存；发布软件时，将程序所依赖的所有动态库都复制给用户</p><p><strong>运行时</strong></p><p>分布式程序：需要多个运行程序，分别部署于多个计算机物理环境</p><p>代码快照：描述程序运行时内存里变量层面的状态</p><p>内存转储（Memory dump）：一个包含进程内存拷贝的磁盘文件，包含程序异常退出时的寄存器、调用栈、程序数据等，调试器可以加载转储文件并显示信息</p><p>执行跟踪（Execution tracing）：软件层面，用日志方式记录程序执行的调用次序</p><p>事件日志：系统层面的日志</p><h4 id="视图转换"><a class="anchor" href="#视图转换">#</a> 视图转换</h4><p><img data-src="image-20220613215018184.png" alt="image-20220613215018184"></p><p>•∅→Code</p><p><strong>Programming / Coding (ADT/OOP)</strong></p><p>Review, static analysis/checking</p><p>•Code→Component</p><p><strong>Design (ADT/OOP; Reusability; Maintainability)</strong></p><p>Build: compile, static link, package, install, etc</p><p>•Build-time→Run-time</p><p>Install / deploy</p><p><strong>Debug, unit/integration testing (Robustness and Correctness)</strong></p><p>•Moment→Period</p><p><strong>Version control</strong></p><p>Loading, dynamic linking, execution (dumping, profiling, logging)</p><p>Concurrent threads</p><h2 id="软件的质量因素"><a class="anchor" href="#软件的质量因素">#</a> 软件的质量因素</h2><p><strong>外部质量因素</strong>：可被<strong>用户</strong>感知的因素，如软件速度、易用性；影响用户</p><p><strong>内部质量因素</strong>：作为<strong>软件产品</strong>的质量，如代码可读性；影响软件本身和它的开发者</p><p><strong>外部质量取决于内部质量。</strong></p><h4 id="外部质量因素"><a class="anchor" href="#外部质量因素">#</a> 外部质量因素</h4><p><strong>1.</strong> <strong>正确性</strong></p><p>正确性：按照预先定义的<strong>规约</strong>执行，是<strong>最重要</strong>的质量指标</p><p>・测试和调试：发现不正确、消除不正确</p><p>・防御式编程：在写程序的时候就确保正确性</p><p>・形式化方法：通过形式化验证发现问题</p><p><strong>2.</strong> <strong>健壮性鲁棒性</strong></p><p>健壮性：针对异常情况的处理，关键在于出现异常时不要崩溃</p><p>健壮性是对正确性的补充，正确性保证了软件的行为要严格符合规约中定义的行为；健壮性保证了出现规约定义之外的情形的时候，软件要做出恰当的反应。</p><p>“正常” 和 “异常” 是主观而非客观的，未被规约覆盖的情况即为 “异常情况”。</p><p><strong>3.</strong> <strong>可扩展性</strong></p><p>可扩展性：对软件的规约进行修改，是否足够容易</p><p>软件规模越大，扩展起来越不容易。</p><p><strong>4.</strong> <strong>可复用性</strong></p><p>可复用性：一次开发，多次使用</p><p><strong>5.</strong> <strong>兼容性</strong></p><p>兼容性：不同的软件系统之间相互可容易的集成</p><p>核心是保持设计的同构性，关键在标准化。</p><p><strong>6.</strong> <strong>性能</strong></p><p>除非有足够的正确性，否则性能毫无意义。对性能的关注要与其他质量属性进行折中，过度的优化会导致软件不再适应变化和复用。</p><p><strong>7.</strong> <strong>可移植性</strong></p><p>可移植性：软件可方便的在不同的技术环境之间移植，包括硬件和操作系统</p><p><strong>8.</strong> <strong>易用性</strong></p><p>易用性：对用户而言容易学、安装、操作、监控</p><p>提升易用性的方法是给用户提供详细的指南。</p><p>**9. <em>功能性（<em>Functionality）</em></em></p><p>程序设计中一种不适宜的趋势，即软件开发者增加越来越多的功能，企图跟上竞争，其结果是程序极为复杂、不灵活、占用过多的磁盘空间，<strong>忽视整体质量，失去可持续性</strong>。</p><p><strong>10.</strong> <strong>及时性（Timeliness）</strong></p><p>及时性：在用户有对应需求前放出新版本</p><h4 id="内部质量因素"><a class="anchor" href="#内部质量因素">#</a> 内部质量因素</h4><p><strong>源码方面</strong>：行数（LoC）、逻辑复杂度</p><p><strong>结构方面</strong>：耦合、内聚</p><p>除此之外还有<strong>代码可读性、易于理解、清晰、大小</strong>等。</p><h4 id="总结5个核心质量因素"><a class="anchor" href="#总结5个核心质量因素">#</a> 总结：5 个核心质量因素</h4><p><img data-src="image-20220613215515646.png" alt="image-20220613215515646"></p><p><img data-src="image-20220613215529119.png" alt="image-20220613215529119"></p><p><img data-src="image-20220613215535621.png" alt="image-20220613215535621"></p><p><img data-src="image-20220613215541440.png" alt="image-20220613215541440"></p><h2 id="软件测试"><a class="anchor" href="#软件测试">#</a> 软件测试</h2><p>测试是提高软件质量的重要手段，确认软件是否达到可用级别（用户需求），它关注系统的某一侧面的质量特性。</p><p>・测试跟其他活动的目标相反，它的目的是发现错误</p><p>・再好的测试也无法证明系统里不存在错误</p><p>一个好的测试具有这些特征：能发现错误、不冗余、最佳组合、不能太过复杂也不能太过简单。</p><p><strong>测试和调试的区别</strong></p><p>・测试：发现是否存在错误</p><p>・调试：识别错误根源，消除错误</p><h4 id="测试的分类"><a class="anchor" href="#测试的分类">#</a> 测试的分类</h4><p><strong>从范围上看</strong></p><p>・单元测试：针对软件的最小单元模型开展测试（一般来说是在单个方法 / 类的级别），隔离各个模块，容易定位错误和调试</p><p>・集成测试：将多个程序员 / 团队编写的类 / 包 / 组件 / 子系统联合起来测试</p><p>・系统测试：对整个系统进行测试，将硬件、软件、配置信息等看作一个整体</p><p>・验收测试：产品发布之前所进行的软件测试活动，是技术测试的最后一个阶段，目的是确保软件准备就绪，并且可以让最终用户将其用于执行软件的既定功能和任务</p><p>・回归测试：一旦程序被修改，重新执行之前的所有测试以确认修改没有引入新的错误或导致其他代码产生错误</p><p><img data-src="image-20220613215636044.png" alt="image-20220613215636044"></p><p><img data-src="image-20220613215642647.png" alt="image-20220613215642647"></p><p><strong>从静态 / 动态上看</strong></p><p>・静态测试：在编写代码的阶段由程序员或是代码编辑器、编译器等工具进行检查（如语法检查、代码评审）</p><p>・动态测试：通过测试用例实际执行了编写的代码<br>动态测试可能在程序完全编写完成前就用于测试代码的特定节</p><p><strong>从结构上看</strong></p><p>・白盒测试：对程序<strong>内部代码</strong>结构的测试</p><p>・黑盒测试：对程序外部表现出来的<strong>行为</strong>的测试（例如输入输出）</p><p><img data-src="image-20220613215715637.png" alt="image-20220613215715637"></p><h4 id="测试用例及编写"><a class="anchor" href="#测试用例及编写">#</a> 测试用例及编写</h4><p>测试用例：输入 + 执行条件 + 期望结果<br>测试的动机：让代码出错，出错越快越好</p><p><strong>编写测试的过程</strong></p><p>・先写规约，再写符合规约的测试用例</p><p>・写代码、执行测试、有问题再改、再执行测试用例，直到通过它<br>测试驱动开发（TDD）：将需求转化为具体的测试用例，然后软件经过改进，通过新的测试</p><p><img data-src="image-20220613215752800.png" alt="image-20220613215752800"></p><h4 id="黑盒测试"><a class="anchor" href="#黑盒测试">#</a> 黑盒测试</h4><p>黑盒测试关键在于检查程序是否符合规约，完全从函数规约导出测试用例，不考虑函数内部实现。<br>用尽可能少的测试用例，尽快运行，并尽可能大的发现程序的错误。</p><p><strong>等价类划分</strong></p><p>基于等价类划分的测试：将被测函数的输入域划分为等价类，从等价类中导出测试用例<br>每个等价类代表着对输入约束加以满足 / 违反的有效 / 无效数据的集合。</p><p>等价类的假设：对于相似的输入，将会展示相似的行为<br>故可从每个等价类中仅选一个代表作为测试用例，从而降低测试用例数量。</p><p><strong>典型的划分原则</strong></p><p>考虑输入数据是否限定了数值范围，或是指明了特定的值，或是对不同范围的值可能采用不同的计算方案。</p><p><strong>边界值分析</strong></p><p>边界值分析方法是对等价类划分方法的补充。<br>原理：大量的错误发生在输入域的 “边界” 而非中央</p><p>・0 是正数和负数的边界</p><p>・基本类型的边界，如 INT_MAX、INT_MIN</p><p>・集合中的第一个和最后一个元素</p><p><strong>两种覆盖方式</strong></p><p><strong>笛卡尔积：全覆盖</strong></p><p>将多个划分维度上的多个取值组合起来，每个组合都要有一个用例。不过并非所有组合情况都可能。<br>测试完备，但用例数量多，测试代价高。</p><p><strong>覆盖每个取值：最少</strong> <strong>1</strong> <strong>次即可</strong></p><p>每个维度的每个取值至少被 1 个测试用例覆盖一次即可。<br>测试用例少，代价低，但测试覆盖度未必高。</p><p>白盒测试根据程序执行路径设计测试用例，一般较早执行。<br>独立 / 基本路径测试：对程序所有执行路径进行等价类划分，找出有代表性的最简单的路径（例如循环只需执行 1 次），设计测试用例使每一条基本路径被至少覆盖 1 次</p><p><img data-src="image-20220613215929235.png" alt="image-20220613215929235"></p><p><strong>覆盖度测试</strong></p><p>代码覆盖度：已有的测试用例有多大程度覆盖了被测程序，通常用百分比衡量<br>代码覆盖度越低，测试越不充分；但要做到很高的代码覆盖度，需要更多的测试用例，测试代价高。</p><p>语句覆盖：每⼀条语句至少执行一次<br>分支覆盖：判定中每个条件的所有可能结果至少出现一次，并且每个判定本身的所有可能结果也至少出现一次<br>路径覆盖：每条可能执行到的路径至少执行一次</p><p>测试效果：路径覆盖 &gt; 分支覆盖 &gt; 语句覆盖<br>测试难度：路径覆盖 &gt; 分支覆盖 &gt; 语句覆盖</p><p><strong>测试策略</strong></p><p>测试策略：根据什么来选择测试用例 —— 非常重要，需要在程序中<strong>显式</strong>记录下来</p><p>目的：在代码评审过程中，其他人可以理解你的测试，并评判你的测试是否足够充分</p><p><strong>分析工具</strong></p><p>Junit、EclEmma、VisualVM、AppPerfect：动态检查，需要执行代码</p><p>CheckStyle、SpotBugs、PMD：静态检查，无需执行代码</p><h2 id="过程与配置管理"><a class="anchor" href="#过程与配置管理">#</a> 过程与配置管理</h2><h4 id="传统开发模型"><a class="anchor" href="#传统开发模型">#</a> 传统开发模型</h4><p>两种基本类型：线性过程、迭代过程</p><p>选择合适的过程模型的依据：用户参与程度、开发效率 / 管理复杂度、开发出的软件的质量</p><p><strong>瀑布过程</strong></p><p>特点：线性推进、整体推进、非迭代<br>优点：管理简单<br>缺点：无法适应需求增加 / 变化</p><p><img data-src="image-20220613220143709.png" alt="image-20220613220143709"></p><p><strong>增量过程</strong></p><p>特点：线性推进、增量式（多个瀑布的串行）、非迭代<br>优点：比较容易适应需求的增加</p><p><img data-src="image-20220613220156089.png" alt="image-20220613220156089"></p><p><strong>V-Model</strong></p><p>V 模型可以看作瀑布模型的优化，它仍然是<strong>线性推进</strong>的，瀑布模型存在的问题大多在 V-model 中也存在。</p><p>每个开发阶段都有相应的测试对齐进行验证，但是测试与开发是<strong>串行</strong>而非并行进行的，也就是测试需要等开发完成后再开始。</p><p><img data-src="image-20220613220209324.png" alt="image-20220613220209324"></p><p><strong>原型过程</strong></p><p>开发出来之后由用户试用 / 评审，发现问题反馈给开发者，开发者修改原有的实现，继续交给用户评审，循环往复这个过程，直到用户满意为止。重点在于在原型上持续不断地迭代发现用户变化的需求。</p><p>特点：迭代推进<br>优点：开发质量高<br>缺点：时间代价高</p><p><img data-src="image-20220613220222750.png" alt="image-20220613220222750"></p><p><strong>螺旋过程</strong></p><p>・多轮迭代基本遵循瀑布模式</p><p>・每轮迭代有明确的目标 ，遵循 “原型” 过程</p><p>进行严格的风险分析， 方可进入下一轮迭代</p><p><img data-src="image-20220613220237483.png" alt="image-20220613220237483"></p><p><strong>敏捷开发</strong></p><p>敏捷开发，即通过快速迭代和小规模的持续改进，以快速适应变化。</p><p>敏捷宣言四个维度：</p><p>・个体和互动高于流程和工具</p><p>・工作的软件高于详尽的文档</p><p>・客户合作高于合同谈判</p><p>・响应变化高于遵循计划</p><p><img data-src="image-20220613220307468.png" alt="image-20220613220307468"></p><p>敏捷 = 增量 + 迭代，每次迭代处理一个小规模增量。</p><p><img data-src="image-20220613220325998.png" alt="image-20220613220325998"></p><h4 id="软件配置管理和版本控制"><a class="anchor" href="#软件配置管理和版本控制">#</a> 软件配置管理和版本控制</h4><p><strong>软件配置管理（SCM）</strong></p><p>软件配置管理：追踪和控制软件的变化，包括版本控制和软件配置项<br>软件配置项（SCI）：软件中发生变化的<strong>基本</strong>单元（例如：文件）</p><p><img data-src="image-20220613220430743.png" alt="image-20220613220430743"></p><p><strong>版本控制 (VCS)</strong></p><p><img data-src="image-20220613220459060.png" alt="image-20220613220459060"></p><p><strong>版本控制分类</strong></p><p><strong>本地版本控制系统</strong></p><p>仓库存储于开发者本地机器，无法共享和协作。</p><p><img data-src="image-20220613220601892.png" alt="image-20220613220601892"></p><p><strong>集中式版本控制系统</strong></p><p>仓库存储于独立的服务器， 支持多开发者之间的协作。</p><p><img data-src="image-20220613220607339.png" alt="image-20220613220607339"></p><p><strong>分布式版本控制系统</strong></p><p>仓库存储于独立的服务器 + 每个开发者的本地机器。</p><p><img data-src="image-20220613220611826.png" alt="image-20220613220611826"></p><p><strong>Git</strong></p><p>Git 是一个<strong>分布式</strong>版本控制系统</p><p>一个 Git 仓库分为三个部分：</p><p>・.git 目录：本地的 CMDB</p><p>・工作目录：本地文件系统</p><p>・暂存区：.git 目录中的一个文件，隔离工作目录和 Git 仓库</p><p><img data-src="image-20220613220633800.png" alt="image-20220613220633800"></p><p><img data-src="image-20220613220642790.png" alt="image-20220613220642790"></p><p><strong>Object Graph</strong></p><p>对象图是一个<strong>有向无环图</strong>，描述了版本之间的演化关系。一条边 A→B 表示在版本 B 的基础上作出变化，形成了版本 A。</p><p><strong>结构</strong></p><p>・一般：每个 commit 指向一个父亲</p><p>・分支：多个 commit 可指向同一个父亲</p><p>・合并：一个 commit 指向两个父亲</p><p>・一个 “分支” 只是一个指向 commit 的别名</p><p>・HEAD 指向当前工作的 commit</p><p><img data-src="image-20220613220711205.png" alt="image-20220613220711205"></p><p><strong>结点</strong></p><p>一个 commit 存储一个树形结点。tree 中包含了数个 blob；每个 blob 是一个压缩了的仓库文件，不保存文件名信息。</p><p><img data-src="image-20220613220723274.png" alt="image-20220613220723274"></p><p>对于每个文件的每个版本（或是不同文件名但相同内容的文件），Git 只会存储一个 blob，而允许多个 commit tree 指向同一个 blob。<br>一个 commit 中与之前相比未发生变化的文件，无需重复存储。文件未发生变化，则后续多个版本始终指向同一个 blob；文件发生变化了，存储两份不同的 blob，两个版本指向不同的 blob。</p><p><strong>传统</strong> <strong>VCS</strong> <strong>和</strong> <strong>Git</strong> <strong>对比</strong></p><p>传统 VCS：存储版本之间的<strong>变化</strong>（行）</p><p>Git：存储发生变化的<strong>文件</strong>（而非代码行）， 不变化的文件不重复存储</p><p><img data-src="image-20220613220801904.png" alt="image-20220613220801904"></p><p><img data-src="image-20220613220804571.png" alt="image-20220613220804571"></p><p><img data-src="image-20220613220810838.png" alt="image-20220613220810838"></p><p><img data-src="image-20220613220819079.png" alt="image-20220613220819079"></p><h4 id="软件构造的一般过程"><a class="anchor" href="#软件构造的一般过程">#</a> 软件构造的一般过程</h4><p>软件构造的一般过程包括编码、重构、调试、测试、性能分析、代码评审、构建。</p><p><strong>编码</strong></p><p>从用途上划分：编程语言、建模语言、配置语言、构建语言<br>从形态上划分：基于语言学的构造语言、基于数学的形式化构造语言、基于图形的可视化构造语言</p><p>建模语言：用于可视化、推理、验证和传达系统设计</p><p>配置语言：用于配置程序的参数和初始设置</p><p><img data-src="image-20220613220856572.png" alt="image-20220613220856572"></p><p><strong>代码评审</strong></p><p>・结对编程</p><p>・走查</p><p>・正式评审会议</p><p>・自动化评审</p><p><strong>性能分析</strong></p><p>・动态分析：执行程序并观察现象、收集数据、分析不足</p><p>・Profiling：对代码的运行时状态和性能进行度量，发现代码中的潜在问题</p><h2 id="数据类型与类型检验"><a class="anchor" href="#数据类型与类型检验">#</a> 数据类型与类型检验</h2><p><img data-src="image-20220613221008218.png" alt="image-20220613221008218"></p><p><strong>类型检查</strong></p><p>・静态类型语言：在编译阶段进行类型检查，所有变量的类型在编译期就已经确定</p><p>・动态类型语言：在运行阶段进行类型检查，变量的类型在运行期才能确定</p><p>・静态类型检查：可发现语法错误、类名 / 函数名错误、参数数目错误、参数类型错误、返回值类型错误<br>静态类型检查可在编译阶段发现错误，避免了将错误带入到运行阶段，可提高程序正确性 / 健壮性</p><p>・动态类型检查：可发现非法的参数值、非法的返回值、越界、空指针</p><p>静态类型检查是关于 “类型” 的检查，不考虑值；动态检查是关于 “值” 的检查。<br>Java 是一种静态类型语言，它同时具有静态类型检查和动态类型检查。</p><p><strong>改变变量和值的区别</strong></p><p>改变一个变量：将该变量指向另一个值的存储空间<br>改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值</p><p><strong>不变性</strong></p><p>不变数据类型（immutable type）：一旦被创建，其值不能改变<br>引用不变：一旦确定其指向的对象，不能再被改变（但其值是可能变化的）</p><p><strong>Java</strong> <strong>中的</strong> <strong>final</strong> <strong>关键字</strong></p><p>・final 类无法派生子类</p><p>・final 方法无法被子类重写</p><p>・final 变量无法改变其<strong>引用</strong>（而非值）</p><p><strong>不可变类型（immutable）</strong></p><p>一旦被创建，就始终<strong>代表</strong>（对外表现出）同样的值。</p><p>对于不可变类型，频繁对其运算会产生大量的临时拷贝，可变类型能最少化拷贝以提高效率。因此，使用可变数据类型，可获得更好的性能，也适合于在多个模块之间共享数据。</p><p>而不可变类型更 “安全”， 在其他质量指标上表现更好。例如，向任何方法传入不可变类型的值，不用担心其值被意外修改；多线程可以安全地持有同一个不可变类型的引用，而不用担心竞争。</p><p><strong>保护可变类型</strong></p><p>・防御式拷贝：给客户端返回一个全新的对象<br>大部分时候该拷贝不会被客户端修改， 可能造成大量的内存浪费</p><p>・单引用局部变量：把对 mutable 对象的引用限制在类 / 方法内，不对外暴露<br>如果存在多个引用，使用可变类型就非常不安全</p><h4 id="快照图"><a class="anchor" href="#快照图">#</a> 快照图</h4><p>快照图用于描述程序运行时的内部状态。使用快照图便于程序员之间的交流、刻画各类变量随时间变化、解释设计思路。</p><p><strong>基本类型</strong></p><p>在箭头末端填写值。</p><p><img data-src="image-20220613221323603.png" alt="image-20220613221323603"></p><p>快照图用于描述程序运行时的内部状态。使用快照图便于程序员之间的交流、刻画各类变量随时间变化、解释设计思路。</p><p><strong>对象类型</strong></p><p>在箭头末端画一个椭圆，在其中写上对象的类名，更详细的话再包含内部属性。<br>可变类型对象的椭圆使用单线，而不可变类型的椭圆使用双线。</p><p><img data-src="image-20220613221359513.png" alt="image-20220613221359513"></p><p><img data-src="image-20220613221404442.png" alt="image-20220613221404442"></p><h4 id="有用的不可变类型"><a class="anchor" href="#有用的不可变类型">#</a> 有用的不可变类型</h4><p>基本类型及其封装对象类型都是不可变的，高精度数 BigInteger 和 BigDecimal 也是不可变的。</p><p>不要使用 Date，因为它是可变类型。相反，使用 java.time 包下的类，如 LocalDateTime。</p><p>Java 中的常用容器如 ArrayList、HashMap 等都是 mutable 的，如果希望容器不可变，可使用包装器 Collections.unmodifiableList 等获取一个不可变的包装对象 —— 当调用 mutator 方法时会抛出一个异常。</p><p>然而，这种 “不可变” 是在运行阶段获得的，编译阶段无法据此进行静态检查。同时，wrapper 仅仅保证了无法通过 wrapper 引用修改对象，但如果通过被包装对象的引用修改了对象的值，wrapper 引用指向的对象仍然会被修改。</p><div class="tags"><a href="/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="ic i-tag"></i> 软件构造学习</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-06-13 22:25:53" itemprop="dateModified" datetime="2022-06-13T22:25:53+08:00">2022-06-13</time> </span><span id="2022/05/15/软构学习三/" class="item leancloud_visitors" data-flag-title="软构学习三" title="Views"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">Views</span> <span class="leancloud-visitors-count"></span> <span class="text">times</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="那我就让时光倒流 WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="那我就让时光倒流 Alipay"><p>Alipay</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>那我就让时光倒流 <i class="ic i-at"><em>@</em></i>你越安静,你能听到的就越多</li><li class="link"><strong>Post link: </strong><a href="https://0x401000nu1l.github.io/2022/05/15/%E8%BD%AF%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B8%89/" title="软构学习三">https://0x401000nu1l.github.io/2022/05/15/软构学习三/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/05/11/DASCTFxSU-RE-wp/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giph4lm9i7j20zk0m84qp.jpg" title="DASCTFxSU_RE_wp"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i></span><h3>DASCTFxSU_RE_wp</h3></a></div><div class="item right"><a href="/2022/06/04/2022CISCN_%E9%80%86%E5%90%91/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipexe4oykj20zk0m87ji.jpg" title="2022CISCN_逆向"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i></span><h3>2022CISCN_逆向</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B91-4%E7%AB%A0%E5%A4%8D%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">课程内容 1-4 章复习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%A4%9A%E7%BB%B4%E5%BA%A6%E8%A7%86%E5%9B%BE%E5%92%8C%E8%B4%A8%E9%87%8F%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.</span> <span class="toc-text">一。多维度视图和质量目标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E8%A7%88"><span class="toc-number">1.1.1.</span> <span class="toc-text">总览</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">视图转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%B4%A8%E9%87%8F%E5%9B%A0%E7%B4%A0"><span class="toc-number">1.2.</span> <span class="toc-text">软件的质量因素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E8%B4%A8%E9%87%8F%E5%9B%A0%E7%B4%A0"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">外部质量因素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E8%B4%A8%E9%87%8F%E5%9B%A0%E7%B4%A0"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">内部质量因素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%935%E4%B8%AA%E6%A0%B8%E5%BF%83%E8%B4%A8%E9%87%8F%E5%9B%A0%E7%B4%A0"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">总结：5 个核心质量因素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">1.3.</span> <span class="toc-text">软件测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">测试的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%8F%8A%E7%BC%96%E5%86%99"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">测试用例及编写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">黑盒测试</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">过程与配置管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">传统开发模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%92%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">软件配置管理和版本控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9A%84%E4%B8%80%E8%88%AC%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">软件构造的一般过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%A3%80%E9%AA%8C"><span class="toc-number">1.5.</span> <span class="toc-text">数据类型与类型检验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E5%9B%BE"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">快照图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%94%A8%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">有用的不可变类型</span></a></li></ol></li></div><div class="related panel pjax" data-title="Related"></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="那我就让时光倒流" data-src="/images/avatar.jpg"><p class="name" itemprop="name">那我就让时光倒流</p><div class="description" itemprop="description">(σﾟ∀ﾟ)σ..:*☆哎哟不错哦</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">17</span> <span class="name">posts</span></a></div><div class="item tags"><a href="/tags/"><span class="count">13</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tLzB4NDAxMDAwTnUxbA==" title="https:&#x2F;&#x2F;github.com&#x2F;0x401000Nu1l"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOnhpbmR1MTEwNkBnYW1pbC5jb20=" title="mailto:xindu1106@gamil.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/05/11/DASCTFxSU-RE-wp/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/06/04/2022CISCN_%E9%80%86%E5%90%91/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2022/04/12/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%82%B8%E5%BC%B9/" title="二进制炸弹">二进制炸弹</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/06/04/2022CISCN_%E9%80%86%E5%90%91/" title="2022CISCN_逆向">2022CISCN_逆向</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/06/13/%E8%BD%AF%E6%9E%84%E5%AD%A6%E4%B9%A0%E5%9B%9B/" title="软构学习四">软构学习四</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/04/13/plan/" title="plan">plan</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/05/15/%E8%BD%AF%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B8%89/" title="软构学习三">软构学习三</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/04/20/%E8%BD%AF%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B8%80/" title="软构学习一">软构学习一</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/04/29/%E5%B7%A6%E8%BD%AC/" title="左转">左转</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/05/03/DASCTF%E5%9B%9B%E6%9C%88%E9%80%86%E5%90%91%E9%83%A8%E5%88%86wp/" title="DASCTF X FATE逆向部分wp">DASCTF X FATE逆向部分wp</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/04/20/starCTF%E9%80%86%E5%90%91wp/" title="starCTF逆向wp">starCTF逆向wp</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/06/13/%E8%BD%AF%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%BA%94/" title="软构学习五">软构学习五</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">那我就让时光倒流 @ 那我就让时光倒流</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">89k words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">1:21</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/05/15/软构学习三/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>